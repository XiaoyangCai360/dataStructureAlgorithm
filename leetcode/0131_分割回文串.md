# 0131. 分割回文串 Palindrome Partioning
[Leetcode 题目链接](https://leetcode.cn/problems/palindrome-partitioning/)

## 1. 题目描述
给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

示例 1：
```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

示例 2：
```
输入：s = "a"
输出：[["a"]]
```

## 2. 解题思路
- 本题参考[0078. 子集](/leetcode/0078_子集.md)。

回溯算法的模版为：
```Py
    res = [] # 最后返回的结果列表，即遍历所有树后的结果集合
    path = [] # 记录当前路径

    def backtrack(选择列表) -> None:
        if 满足结束条件：
            res.append(path.copy()) # 把当前路径加入到结果列表中
            return

        for 选择 in 选择列表：
            做出选择

            backtrack(选择列表) # 做出当前选择后，更新后的选择列表

            撤回选择
```

### 2.1 子集型回溯 - 输入的视角
- 本题要求找到找到给定的字符串`s`中所有的回文子串，如果从 **答案的视角** 出发，可以考虑字符串`s`中每两个字符中间的 **逗号** 选择或者不选择。

### 2.1.1 回溯三问
- **选择列表：** 字符串`s`中每两个字符中间的逗号 **选择或者不选**，因此有 **两个** 选项。
- **路径：** 用`path`记录路径上的元素（已经做出的选择）

1. **当前操作是什么：** 枚举字符串`s`中 **第`i`个字符** 和 **第`i + 1`个字符** 之间的逗号 选择或者不选
2. **子问题是什么：** 分割下标从`i`开始的回文子串，当前开始字符为`start`
3. **下一个子问题是什么：** 分割下标从`i + 1`开始的回文子串，当前开始字符为`i + 1`

### 2.1.2 回溯函数
回溯函数的本质是递归函数，因此，遵循递归的基本逻辑。

**1. 确定递归函数的参数和返回值**
- 定义回溯函数`backtrack`，参数为第`i`个子问题，和当前字符的开始`start`，没有返回值
```Py
    def backtrack(i: int, start: int) -> None:
```

**2. 确定递归的终止条件**: 即回溯结束时的边界条件，也就是遍历树 的边界条件
- 如果当前的子问题为`n`个子问题（`n = len(nums)`），即`i == n`，说明的子问题为分割下标大于等于`n`的回文子串，因此说明字符串`s`已经遍历完
- 把当前路径`path`加入到结果列表中`res`，并返回`return`
- **注意：** 因为路径`path`是一个全局变量，为了保证每个路径的单独性，需要加入到`res`中的是路径的 **深拷贝**，即`path.copy()`
```Py
    if i == n:
        res.append(path.copy())
        return
```

**3. 确定单层递归的逻辑**：即在决策树当前节点的当前操作
- 相当于遍历到每个决策树的节点时，即对于选择列表中的两个选项 **选与不选** 来说:
  - **不选**：即不选字符串下标`i`和`i + 1`字符之间的逗号，因此需要先判断当前`i`在字符串之内（`i < n - 1`），直接向下递归
    - 下一个子问题为分割下标大于等于`i + 1`的回文子串，并且子串的开始字符依然为`start`
  - **选**：即选择字符串下标`i`和`i + 1`字符之间的逗号，所以有：
    - **做出选择**：当前子串`t = s[start, i]`，即从`start`到`i`之间的字符串；判断当前子串`t`是否是 **回文子串**，如果是，把当前子串`t`加入到路径`path`中
    - **继续递归**：然后继续向下递归，下一个子问题为分割下标大于等于`i + 1`的回文子串，并且子串的开始字符下标为`i + 1`
    - **撤回选择**：路径`path`中删除刚刚加入的子串`t`
```Py
    # 不选
    if i < n - 1:
        backtrack(i + 1, start)

    # 选
    t = s[start, i + 1]
    if t == t[::-1]: # 判断回文串
        path.append(t) # 做出选择

        backtrack(i + 1, i + 1)

        path.pop() # 撤回选择
```

**4. 调用递归函数**
- 定义全局变量`res`为结果列表，存储遍历决策树的所有结果
- 定义全局变量`path`为路径列表，记录当前路径
- 调用回溯函数`backtrack`，参数为第`0`个子问题，和当前字符的开始`0`
- 最后返回结果列表`res`


### 2.2 子集型回溯 - 答案的视角
- 如果从 **答案的视角** 出发，可以考虑枚举字符串`s`来构成的子串是否是回文串。

### 2.2.1 回溯三问
- **选择列表：** 字符串`s`中的下标 **大于等于`i`的** 每个字符；为了避免出现重复，需要定义选择列表的范围为 **严格递增**，所以可以规定每次从`s`中下标`>= i`的部分中构建子集时，做出的选择需要满足`j >= i`。
- **路径：** 用`path`记录路径上的元素（已经做出的选择）

1. **当前操作是什么：** 枚举当前子串`s[i .. j]`是否是回文串
2. **子问题是什么：** 分割下标大于等于`i`开始的回文子串
3. **下一个子问题是什么：** 分割下标大于等于`i + 1`开始的回文子串

### 2.1.2 回溯函数
回溯函数的本质是递归函数，因此，遵循递归的基本逻辑。

**1. 确定递归函数的参数和返回值**
- 定义回溯函数`backtrack`，参数为第`i`个子问题，没有返回值
```Py
    def backtrack(i: int) -> None:
```

**2. 确定递归的终止条件**: 即回溯结束时的边界条件，也就是遍历树 的边界条件
- 如果当前的子问题为`n`个子问题（`n = len(nums)`），即`i == n`，说明的子问题为分割下标大于等于`n`的回文子串，因此说明字符串`s`已经遍历完
- 把当前路径`path`加入到结果列表中`res`，并返回`return`
- **注意：** 因为路径`path`是一个全局变量，为了保证每个路径的单独性，需要加入到`res`中的是路径的 **深拷贝**，即`path.copy()`
```Py
    if i == n:
        res.append(path.copy())
        return
```

**3. 确定单层递归的逻辑**：即在决策树当前节点的当前操作
- 相当于遍历到每个决策树的节点时，即对于选择列表，即字符串`s`中的下标 **大于等于`i`的** 每个字符来说：
  - **做出选择**：当前子串为`t = s[i, j + 1]`，判断当前子串`t`是否是回文串；如果是，把当前子串`t`加入到路径`path`中
  - **继续递归**：继续向下递归，此时的下一个子问题为 **分割下标大于等于`i + 1`开始的回文子串**
  - **撤回选择**：路径`path`中删除刚刚加入的子串`t`

**4. 调用递归函数**
- 定义全局变量`res`为结果列表，存储遍历决策树的所有结果
- 定义全局变量`path`为路径列表，记录当前路径
- 调用回溯函数`backtrack`，参数为第`0`个子问题
- 最后返回结果列表`res`



**时间复杂度**：`O(n * 2 ^ n)`。`n`为`nums`数组的长度。因为每次做选择只有 **选** 或者 **不选** 两个选择，因此一共有`2 ^ n`中情况。`path.copy()`的时间复杂度为`O(n)`。

**空间复杂度**：`O(1)`。如果考虑递归用到的系统栈，则空间复杂度是`O(n)`。


## 3. 算法实现
### 3.1 子集型回溯 - 输入的视角
```Py
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        if not s:
            return []

        path = []
        res = []

        n = len(s)

        def backtrack(i, start) -> None:
            if i == n:
                res.append(path.copy())
                return

            # 不选
            if i < n - 1:
                backtrack(i + 1, start)

            # 选
            t = s[start: i + 1]
            if t == t[::-1]:
                path.append(t)

                backtrack(i + 1, i + 1)

                path.pop()
                
        backtrack(0, 0)
        return res
```

### 3.2 子集型回溯 - 答案的视角
```Py
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        '''
            回溯三问：
            1. 当前操作：选择回文子串s[i..j]加入path
            2. 子问题：从s[i:]中构建回文串
            3. 下一个子问题：从s[i+1:]中构建回文串
        '''
        if not s:
            return []

        res = []
        path = []
        n = len(s)
        def backtrack(i):
            if i == n:
                res.append(path.copy())
                return
            
            for j in range(i, n):
                t = s[i:j+1]

                # 判断字符串是否是回文串
                if t == t[::-1]:
                    path.append(t)
                    backtrack(j + 1)
                    path.pop()

        backtrack(0)
        return res
```