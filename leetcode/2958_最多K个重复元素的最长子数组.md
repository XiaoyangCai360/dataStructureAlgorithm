# 2958. 最多K个重复元素的最长子数组 Length of Longest Subarray With Atmost K Frequency
[Leetcode 题目链接](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/description/)

## 1. 题目描述
给你一个整数数组 `nums` 和一个整数 `k` 。

一个元素 `x` 在数组中的 **频率** 指的是它在数组中的出现次数。

如果一个数组中所有元素的频率都 **小于等于 k** ，那么我们称这个数组是 **好** 数组。

请你返回 `nums` 中 **最长好** 子数组的长度。

**子数组** 指的是一个数组中一段连续非空的元素序列。

示例1:
```
输入：nums = [1,2,3,1,2,3,1,2], k = 2
输出：6
解释：最长好子数组是 [1,2,3,1,2,3] ，值 1 ，2 和 3 在子数组中的频率都没有超过 k = 2 。[2,3,1,2,3,1] 和 [3,1,2,3,1,2] 也是好子数组。
最长好子数组的长度为 6 。
```

示例2:
```
输入：nums = [1,2,1,2,1,2,1,2], k = 1
输出：2
解释：最长好子数组是 [1,2] ，值 1 和 2 在子数组中的频率都没有超过 k = 1 。[2,1] 也是好子数组。
最长好子数组的长度为 2 。
```

示例3:
```
输入：nums = [5,5,5,5,5,5,5], k = 4
输出：4
解释：最长好子数组是 [5,5,5,5] ，值 5 在子数组中的频率没有超过 k = 4 。
最长好子数组的长度为 4 。
```

## 2. 解题思路
- 本题参考 [0003. 无重复字符的最长子串](/leetcode/0003_无重复字符的最长子串.md)
- 题目要求找到所有元素出现频率都小于等于`k`的子数组，可以用哈希表，即`dict()`，来统计子数组中各个元素出现的次数，维持窗口中各个元素出现的频率都 **小于等于`k`**

### 2.1 滑动窗口
* 类似数组双指针，用一个循环做两个循环的遍历
* **滑动窗口**：不断改变子串的**起始位置**和**终止位置**，直到找到符合条件的子串
* **窗口**：所有元素出现频率都小于等于`k`的子数组；所以窗口维持的是 **所有元素出现频率都小于等于`k`的子数组** 长度
* 移动窗口的**终止位置**（即`right`指针）：用`for`循环遍历
* 移动窗口的**起始位置**（即`left`指针）：当`right`指针遍历到的元素出现频率 **大于`k`** 时，更新`left`指针向右移动 **缩小窗口**，直到窗口内所有元素出现的频率都 **小于等于`k`**

具体算法：
- 定义`res = float('-inf)`为最长好子数组的长度，初始化为负无穷大
- 定义`count = dict()`存储每个元素出现的频率。
- 定义`left = 0`初始化左指针。
- 定义`right`开始 **外层`for`循环**：`for right, c in enumerate(nums)`
  - 处理当前元素：`right`每遍历到一个元素，`count`中更新`nums[right]`出现的频率加`1`
  - 开始 **内层循环** 缩小窗口，循环条件为，如果`left <= right`并且`nums[right]`的频率大于`k`时：
    - 缩小窗口的左边界：`count`中更新`nums[left]`出现的频率减去`1`，`left += 1`向右移动一位
  - 内层循环结束时，说明窗口中维持了 **所有元素出现频率都小于等于`k`的子数组**
  - 统计当前窗口的大小，与`res`相判断；如果当前窗口长度大于`res`，就更新`res`等于当前窗口的大小，即`res = max(res, right - left + 1)`
  - 右指针`right += 1`向右移动一位 
- 返回`res`

**时间复杂度**：`O(n)`。因为在滑动窗口中，`right`指针从`0`移动到`n - 1`，至多移动了`n`次；`left`指针只有`left += 1`也至多移动了`n`次，所以总的时间复杂度为`O(n) + O(n) = O(n)`。
**空间复杂度**：`O(1)`。因为题目限制条件中定义`s`是一个由英文字母、数字和空格组成的字符串，所以可以认为`s`是一个ASCII字符，则总共有 **128** 中字符，所以可以认为空间复杂度为`O(128) = O(1)`。

#### 滑动窗口的模版
```Py
    n = len(nums)

    left = 0 # 定义左指针

    # 外层循环拓展右边界，right += 1
    # 内层循环拓展左边界，left += 1
    for right, num in enumerate(nums): # 右指针从0到n-1
        # 考虑当前的元素
        while left <= right and check(): # [left, right]不符合题意时，缩短左边界

        # [left, right]符合题意，统计当前窗口的性质
```

## 3. 算法实现
```Py
class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        if not nums:
            return 0

        res = -inf

        count = dict()

        left = 0

        for right, x in enumerate(nums):
            count[x] = count.get(x, 0) + 1

            while left <= right and count[x] > k:
                count[nums[left]] -= 1
                left += 1

            res = max(res, right - left + 1)

        return res
```