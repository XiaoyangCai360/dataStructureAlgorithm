# 0077. 组合 Combination
[Leetcode 题目链接](https://leetcode.cn/problems/combinations/description/)

## 1. 题目描述
给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

示例 1：
```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

示例 2：
```
输入：n = 1, k = 1
输出：[[1]]
```

## 2. 解题思路
- 本题属于回溯问题中的 **组合型回溯**，
- 相比 **子集型回溯**，组合型回溯可以运用 **剪枝** 进行进一步优化。

回溯算法的模版为：
```Py
    res = [] # 最后返回的结果列表，即遍历所有树后的结果集合
    path = [] # 记录当前路径

    def backtrack(选择列表) -> None:
        if 满足结束条件：
            res.append(path.copy()) # 把当前路径加入到结果列表中
            return

        for 选择 in 选择列表：
            做出选择

            backtrack(选择列表) # 做出当前选择后，更新后的选择列表

            撤回选择
```

### 2.1 组合型回溯 - 输入的视角
- 本题要求找到范围`[1, n]`中所有可能的`k`个数的组合，可以枚举在选择列表`[1, n]`中第`i`个数 **选/不选**

### 2.1.1 回溯三问
- **选择列表：** 枚举第`i`个数 **选择或者不选**，因此有 **两个** 选项。
- **路径：** 用`path`记录路径上的元素（已经做出的选择）

1. **当前操作是什么：** 枚举第`i`个数 **选择或者不选**，因此有 **两个** 选项。
2. **子问题是什么：** 找出`[i, n]`中所有可能的`k`个数的组合
3. **下一个子问题是什么：** 找出`[i + 1, n]`中所有可能的`k`个数的组合

### 2.1.2 剪枝
- **组合型回溯** 可以运用 **剪枝** 筛选不符合题意的节点，提前返回，从而进行优化
- 本题中，如果选择列表中还剩余的数  **小于** 还需要选择的个数，则说明当前情况下没有符合条件的`k`个数组合，可以提前返回
- 因此，假设当前路径的长度为`m = len(path)`，当前的问题为找出`[i, n]`中所有可能的`k`个数的组合，则还剩余的选择个数为`n - i + 1`，还需要选择的个数为`k - m`
- 则如果`n - i + 1`小于`k - m`，说明当前情况下没有符合条件的组合，直接返回
```Py
    m = len(path)
    if n - i + 1 < k - m:
        return
```

### 2.2 子集型回溯 - 答案的视角
- 如果从 **答案的视角** 出发，可以考虑枚举长度为`k`的组合中，第`i`个数有哪些选择

### 2.2.1 回溯三问
- **选择列表：** `[1, n]` **大于等于`i`的** 每个数字；为了避免出现重复，需要定义选择列表的范围为 **严格递增**，所以可以规定每次从`>= i`的部分中构建子集时，做出的选择需要满足`j >= i`。
- **路径：** 用`path`记录路径上的元素（已经做出的选择）

1. **当前操作是什么：** 当前选择列表为`[i, n]`，枚举组合中`j >= i`的部分
2. **子问题是什么：** 枚举`[i, n]`中长度为`k`的组合中
3. **下一个子问题是什么：** 枚举`[j + 1, n]`中长度为`k`的组合中
4. 
**时间复杂度**：`O(k* C(n, k))`。回溯问题时间复杂度通用公式：**路径长度 * 搜索树的叶子数**。对于本题，路径长度为`k`，搜索树的叶子树为`C(n, k)`。

**空间复杂度**：`O(1)`。如果考虑递归用到的系统栈，则空间复杂度是`O(k)`。


## 3. 算法实现
### 3.1 组合型回溯 - 输入的视角
```Py
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        if k == 0:
            return []

        res = []
        path = []

        def backtrack(i) -> None:
            m = len(path)
            if len(path) == k:
                res.append(path.copy())
                return

            # 剪枝
            if n - i + 1 < k - m:
                return

            # 不选
            backtrack(i + 1)

            # 选
            path.append(i)
            backtrack(i + 1)
            path.pop()

        backtrack(1)
        return res
```

### 3.2 子集型回溯 - 答案的视角
```Py
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        if k == 0:
            return []

        res = []
        path = []

        def backtrack(i) -> None:
            m = len(path)
            # 剪枝
            if n - i + 1 < k - m:
                return

            if len(path) == k:
                res.append(path.copy())
                return
            
            for j in range(i, n + 1):
                path.append(j) # 选择
                backtrack(j + 1)
                path.pop() # 撤回选择

        backtrack(1)
        return res
```