# 0078. 子集 Subsets
[Leetcode 题目链接](https://leetcode.cn/problems/subsets/)

## 1. 题目描述
给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的 **子集（幂集）**。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

示例 1：
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

示例 2：
```
输入：nums = [0]
输出：[[],[0]]
```

## 2. 解题思路
- 本题参考 [0046. 全排列](/leetcode/0046_全排列.md)。

### 2.1 子集型回溯 - 输入的视角
- 本题要求找到给定一个元素 **各不相同** 的数组`nums`，要求返回该数组所有可能的子集。
- 因此，对于数组`nums`内每个元素`x`来说有两个选择：**在当前节点中选择`x`** 或者 **在当前节点不选择`x`**

#### 2.1.1 回溯三问
- **选择列表：** 数组`nums`中的每个元素有两个选择：选/不选
- **路径：** 用`path`记录路径上的元素（已经做出的选择）

1. **当前操作是什么：** 枚举数组`nums`中第`i`个数选/不选
2. **子问题是什么：** 从选择列表中下标`>= i`的部分构造子集
3. **下一个子问题是什么：** 从选择列表中下标`>= i + 1`的部分构建子集

因此，可以确认出回溯函数的递归方程为：
```                 
    backtrack(i) -> backtrack(i + 1)
```
 
#### 2.1.2 回溯函数
回溯函数的本质是递归函数，因此，遵循递归的基本逻辑。

**1. 确定递归函数的参数和返回值**
- 定义回溯函数`backtrack`，参数为第`i`个子问题，没有返回值
```Py
    def backtrack(i: int) -> None:
```

**2. 确定递归的终止条件**: 即回溯结束时的边界条件，也就是遍历树 的边界条件
- 如果当前问题是从数组`nums`中下标为`i >= n`（`n = len(nums)`）的部分构建子集，因为已经超出了`nums`的长度，说明没有剩余的元素可以做选择，因此所有的选择都做完了
- 把当前路径`path`加入到结果列表中`res`，并返回`return`
- **注意：** 因为路径`path`是一个全局变量，为了保证每个路径的单独性，需要加入到`res`中的是路径的 **深拷贝**，即`path.copy()`
```Py
    if i == n:
        res.append(path.copy())
        return
```

**3. 确定单层递归的逻辑**：即在决策树当前节点的当前操作
- 因为此时的选择列表为 **两个选择**，即`nums`中的每个元素 **选/不选**，因此相当于决策树是一个 **二叉树**，遍历二叉树的过程参考 **中续遍历**
  - 先遍历 **左子树**，即`nums`中当前元素 **不选择进入**`path`，则直接向下递归，即直接递归进入下一个子问题，`backtrack(i + 1)`
  - 然后遍历 **右子树**，即`nums`中当前元素 **选择进入** `path`，遵循常规的回溯框架：
    - **做出选择**: 把当前的选择`nums[i]`加入到路径`path`
    - 继续向下递归进入下一个子问题，即`backtrack(i + 1)`
    - **撤回选择**：撤回当前做出的选择，即在路径中弹出`nums[i]`

**4. 调用递归函数**
- 定义全局变量`res`为结果列表，存储遍历决策树的所有结果
- 定义全局变量`path`为路径列表，记录当前路径
- 调用回溯函数`backtrack`，参数为`nums`下标第`0`个数字开始枚举
- 最后返回结果列表`res`

### 2.2 子集型回溯 - 答案的视角
### 2.2.1 回溯三问
- 从答案的视角，判断路径`path`中第一个数选谁，第二个数选谁……以此类推，每一个决策树的节点都是答案
- **注意**：为了避免出现重复，比如`[1,2]`和`[2,1]`，需要定义选择列表的范围为 **严格递增**，所以可以规定每次从`nums`中下标`>= i`的部分中构建子集时，做出的选择需要满足`j >= i`
- **选择列表**：数组`nums`
- **路径：** 用`path`记录路径上的元素（已经做出的选择）

1. **当前操作是什么**：当前的选择列表为`nums`中`j >= i`的部分，从中选择`nums[j]`加入到路径`path`中
2. **子问题是什么**：从`nums`中下标为`>= i`的部分构建子集
3. **下一个子问题是什么**：从`nums`中下标为`>= j + 1`的部分构建子集


因此，可以确认出回溯函数的递归方程为：
```                 
    backtrack(i) -> backtrack(i + 1)
```

#### 2.2.2 回溯函数
回溯函数的本质是递归函数，因此，遵循递归的基本逻辑。

**1. 确定递归函数的参数和返回值**
- 定义回溯函数`backtrack`，参数为第`i`个子问题，没有返回值
```Py
    def backtrack(i: int) -> None:
```

**2. 确定递归的终止条件**: 即回溯结束时的边界条件，也就是遍历树 的边界条件
- 每个递归函数的开始，把路径`path`加入到结果列表`res`中，相当于保存上一个子问题的路径
- **注意：** 因为路径`path`是一个全局变量，为了保证每个路径的单独性，需要加入到`res`中的是路径的 **深拷贝**，即`path.copy()`
- 如果当前问题是从数组`nums`中下标为`i >= n`（`n = len(nums)`）的部分构建子集，因为已经超出了`nums`的长度，说明没有剩余的元素可以做选择，因此所有的选择都做完了
- 因此，直接返回
```Py
    res.append(path.copy())
    if i == n:
        return
```

**3. 确定单层递归的逻辑**：即在决策树当前节点的当前操作
- 当前的选择列表为`nums`中`j >= i`的部分，从中选择`nums[j]`加入到路径`path`中
- 因此，相当于遍历当前节点的`N`个子树，开始循环：对于`j`在`[i, len(nums))`的范围来说，每个选择都是一个子树
  - **做出选择**：把当前的选择`nums[j]`加入到路径`path`
  - **继续递归**：继续向下递归，参数为`j + 1`，因为对于下一个子问题来说，选择列表是`nums`数组中下标`>= j + 1`的部分
  - **撤回选择**：路径`path`中弹出做出的选择`nums[j]`

**4. 调用递归函数**
- 定义全局变量`res`为结果列表，存储遍历决策树的所有结果
- 定义全局变量`path`为路径列表，记录当前路径
- 调用回溯函数`backtrack`，参数为`nums`下标第`0`个数字开始枚举
- 最后返回结果列表`res`


**时间复杂度**：`O(n * 2^n)`。`n`为数组`nums`的长度。因为每次做选择只有 **选** 或者 **不选** 两个选择，因此一共有`2 ^ n`中情况。`path.copy()`的时间复杂度为`O(n)`。

**空间复杂度**：`O(1)`。如果考虑递归用到的系统栈，则空间复杂度是`O(n)`。


## 3. 算法实现
### 3.1 子集型回溯 - 输入的视角
```Py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        if not nums:
            return []

        res = []
        path = []
        n = len(nums)
        def backtrack(i: int) -> None:
            if i == n:
                res.append(path.copy())
                return
            
            backtrack(i + 1)
            
            x = nums[i]
            path.append(x)

            backtrack(i + 1)

            path.pop()

        backtrack(0)
        return res
```

### 3.2 子集型回溯 - 答案的视角
```Py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        if not nums:
            return []

        res = []
        path = []
        n = len(nums)

        def backtrack(i) -> None:
            res.append(path.copy())
            if i == n:
                return

            for j in range(i, n):
                path.append(nums[j])
                backtrack(j + 1)
                path.pop()

        backtrack(0)
        return res
```