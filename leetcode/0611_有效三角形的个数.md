# 0611. 有效三角形的个数 Valid Triangle Number
[Leetcode 题目连接](https://leetcode.cn/problems/valid-triangle-number/)

## 1. 题目描述

给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。

示例1:
```
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

示例2:
```
输入: nums = [4,2,3,4]
输出: 4
```

## 2. 解题思路
- 本题使用 **排序 + 双指针法**，参考 [0167. 两数之和II-输入有序数组](/leetcode/0167_两数之和II-输入有序数组.md) 和 [2824. 统计和小于目标的下标对数目](/leetcode/2824_统计和小于目标的下标对数目.md)。

### 2.1. 排序 + 双指针法
**注意**：
- 双指针法的前提是数组已经是 **有序** 数组，因此第一步是数组的排序，即`nums.sort()`
- 题意要求判断数组`nums`中可以组成三角形三条边的三元组个数，假设数组`nums`排序好后，有以下`i, j, k`三个索引：
  - `i`从`0`开始向右移动，则`nums[i]`是 **最小** 的边，**设`nums[i] = a`**
  - `j`从`i + 1`开始向右移动，则`nums[j] > nums[j]`，**设`nums[j] = b`**
  - `k`从`len(n) - 1`开始向左移动，则`nums[k]`是 **最大** 的边，即`nums[k] > nums[j] > nums[i]`，**设`nums[k] = c`**
- 根据三角形 **两边之和大于第三条边** 的定理，可以推断出：
  - `a + b > c`
  - `a + c > b`
  - `b + c > a`
- 根据以上定义，因为数组`nums`已经是排序好的数组，所以有`
  - `a + c > b`肯定满足，因为`c > b`
  - `b + c > a`肯定满足，因为`b > a`和`c > a`
- 因此，在判断`a, b, c`能否形成三角形时，只用考虑条件 **`a + b > c`**
- 但是，在原本的 **排序 + 双指针法中**，先定义`i`循环从`0`开始，然后在循环中定义双指针`j, k`循环，所以在不等式中`a + b > c`中，如果`a + b`不大于`c`，有 **两个** 变量`a，b`，不好判断
- 所以先固定外层循环为`k`循环，从`k = 2`开始向右移动，即`for k in range(2, len(nums))`
- 然后进入`i,j`双指针，此时`i = 0`为当前双指针内 **最小值**，`j = k - 1`为当前双指针内 **最大值**，然后在进行判断是否`a + b > c`
  - 如果满足，说明当`nums[j] = b`为双指针最大值时，`i`指针从`nums[i]`到`nums[j]`相加的结果也一定满足，所以一共有`j - i`个满足的数对，即`res += j-i`, 然后更新`j`向左移动一位
  - 如果不满足`a + b > c`，说明当前的`a`太小，就进一步更新`i += 1`

具体算法：
- 首先将数组`nums`排序，即`nums.sort()`
- 定义`res = 0`存放最终返回的结果数目
- 开始外层`k`循环，即`for k in range(2, len(n))`
- 定义左右双指针`i, j = 0, k - 1`
- 开始双指针循环，循环条件为：**当左右双指针不相等时，即`while i < j`**
  - 因为数组已经排序好，当前`i`指向双指针 **最小值**，当前`j`指向双指针 **最大值**
  - 如果当前双指针的元素和`nums[i] + nums[j] > nums[j]`，说明从左指针`i`从`i`到`j`的每一个元素与右指针`j`的组合相加都是大于`target`的，因此一共有`j - i`个合法数对，所以`res += j - i`；然后更新右指针`j -= 1`
  - 否则，说明当前双指针的元素和`nums[i] + nums[j] <= nums[j]`，因为`nums[j]`已经是当前的最大元素，所以说明`nums[i]`过于小了，要更新左指针`i += 1`
- 返回结果`return res`

* **时间复杂度**：`O(n^2)`。数组排序的时间复杂度是`O(nlogn)`。数组外层遍历为`O(n)`。双指针法的时间复杂度是`O(n)`，则总时间复杂度是`O(nlogn) + O(n^2) = O(n^2)`。
* **空间复杂度**：`O(1)`。

## 3. 算法实现
### 3.1 排序 + 双指针法
```Python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        if not nums or len(nums) < 3:
            return 0

        res = 0

        nums.sort()
        n = len(nums)

        for k in range(2, n):
            i, j = 0, k - 1

            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    res += j - i
                    j -= 1
                else:
                    i += 1

        return res
```
