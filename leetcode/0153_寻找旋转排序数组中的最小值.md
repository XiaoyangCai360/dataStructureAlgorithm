# 0153. 寻找旋转排序数组中的最小值 Find Minimum in Rotated Sorted Array
[Leetcode 题目链接](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)

## 1. 题目描述
已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

示例1:
```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

示例2:
```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。
```

示例3:
```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

## 2. 解题思路
- 常规思路为遍历数组找到符合条件的元素，时间复杂度为`O(n)`；但是本题要求算法的时间复杂度为`O(log n)`，因此，可以使用**二分查找法（Binary Search）**
- 本题参考 [0162. 寻找峰值](/leetcode/0162_寻找峰值.md)。

### 2.1 红蓝染色法
> **红蓝染色法**：
> - 定义 **红色区间** 和 **蓝色区间** ，在循环中不断把数组分割成红色和蓝色
> - 寻找 **循环不变量**，即`left`左边都是红色，`right`右边都是蓝色（是否包括`left`和`right`本身需要看使用的是 **左闭右闭** 还是 **左闭右开**）

- 本题中要求找到排序数组旋转后的最小值，可以先定义 **红蓝区间**：
  - 定义`mid`，**比较`nums[mid]`和数组最后一个元素`nums[-1]`**，因为数组是一个排序数组，旋转后满足性质： 假设数组旋转后分成两段，第一段的元素整体都大于第二段元素，且第二段的第一个元素就是整个数组的最小值，则第一段的元素也 **整体都大于** 数组的最后一个元素，而第二段的元素都 **整体小于** 数组最后一个元素

- **红色区间**：最小值 **左侧** 的元素；相当于`nums[mid] > nums[-1]`，则`nums[mid]`在数组 **第一段**，说明`nums[mid]`一定不是最小值，且一定在最小值的左侧

- **蓝色区间**：最小值 **本身** 或 **右侧** 的元素；相当于`nums[mid] < nums[-1]`，则`nums[mid]`在数组 **第二段**，说明`nums[mid]`可能是最小值 **本身** 或者是最小值 **右侧** 的元素

### 2.2 二分查找
- 根据以上 **红蓝染色法** 定义，可以使用二分查找，循环中可以定义 **左闭右闭** 或者 **左闭右开**
- **左闭右闭**：`left`左侧（不包含`left`本身）一定在最小值 **左侧**，`right`右侧（**不包含`right`本身**）一定是最小值 **本身** 或者 在最小值 **右侧**
  - 因此，循环结束时，条件为`right < left`，即`right`过界，说明整个数组都被遍历到
  - 当`right < left`时，根据定义，`right`右侧都是 **蓝色区间**，即要么是最小值本身，要么在最小值右侧；因此，可以推断 **蓝色区间的第一个值** `right + 1`一定是最小值，所以返回`right + 1 = left`
- **左闭右开**：`left`左侧（不包含`left`本身）一定在最小值 **左侧**，`right`右侧（**包含`right`本身**）一定是最小值 **本身** 或者 在最小值 **右侧**
  - 因此，循环结束时，条件为`right = left`，说明整个数组都被遍历到
  - 当`right = left`时，根据定义，`right`右侧（包括`right`）都是 **蓝色区间**，即要么是最小值本身，要么在最小值右侧；因此，可以推断 **蓝色区间的第一个值** `right`一定是最小值，所以返回`right = left` 

**注意**：
- 根据 **红蓝区间** 的定义，可以推断数组最后一个元素`nums[-1]` 一定是 **蓝色区间**，因为最后一个元素一定要么是最小值本身，要么在最小值右侧，所以在初始化循环时，`right`应该定义在`nums[-1]`之前
- 因为题目有限制条件：数组内元素 **互不相同**，所以不用考虑`nums[mid] == nums[-1]`的情况

**时间复杂度**：`O(log n)`。因为每次循环时，数组长度都会减半，所以一共遍历了`log n`长度的数组。
**空间复杂度**：`O(1)`。

## 3. 算法实现
### 3.1 左闭右闭
```Py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        if not nums:
            return -inf

        # [left, right]
        left, right = 0, len(nums) - 2

        while left <= right:
            mid = (left + right) // 2

            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid - 1

        return nums[right + 1] # nums[left]
```

### 3.2 左闭右开
```Py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        if not nums:
            return -inf

        # [left, right)
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2

            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid

        return nums[right] # nums[left]
```