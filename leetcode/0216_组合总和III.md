# 0216. 组合总和III Combination Sum III
[Leetcode 题目链接](https://leetcode.cn/problems/combination-sum-iii/description/)

## 1. 题目描述
找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字`1`到`9`
- 每个数字 **最多使用一次** 
- 返回 **所有可能的有效组合的列表** 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

示例 1：
```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

示例 2：
```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

示例 3：
```
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
```

## 2. 解题思路
- 本题属于回溯问题中的 **组合型回溯**，
- 本题参考 [0077. 组合](/leetcode/0077_组合.md)。

回溯算法的模版为：
```Py
    res = [] # 最后返回的结果列表，即遍历所有树后的结果集合
    path = [] # 记录当前路径

    def backtrack(选择列表) -> None:
        if 满足结束条件：
            res.append(path.copy()) # 把当前路径加入到结果列表中
            return

        for 选择 in 选择列表：
            做出选择

            backtrack(选择列表) # 做出当前选择后，更新后的选择列表

            撤回选择
```

### 2.1 子集型回溯 - 答案的视角
- 如果从 **答案的视角** 出发，可以考虑枚举长度为`k`的组合中，第`i`个数有哪些选择

### 2.2.1 回溯三问
- **选择列表：** `[1, 9]` **大于等于`i`的** 每个数字；为了避免出现重复，需要定义选择列表的范围为 **严格递增**，所以可以规定每次从`>= i`的部分中构建子集时，做出的选择需要满足`j >= i`。
- **路径：** 用`path`记录路径上的元素（已经做出的选择）

1. **当前操作是什么：** 当前选择列表为`[i, 9]`，枚举组合中`j >= i`的部分
2. **子问题是什么：** 枚举`[i, 9]`中长度为`k`的组合中
3. **下一个子问题是什么：** 枚举`[j + 1, 9]`中长度为`k`的组合中
4. 
**时间复杂度**：`O(k* C(9, k))`。回溯问题时间复杂度通用公式：**路径长度 * 搜索树的叶子数**。对于本题，路径长度为`k`，搜索树的叶子树为`C(9, k)`。

**空间复杂度**：`O(1)`。如果考虑递归用到的系统栈，则空间复杂度是`O(k)`。


## 3. 算法实现
### 3.1 子集型回溯 - 答案的视角
```Py
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        if n < k:
            return []

        res = []   
        path = []

        def backtrack(i, target) -> None:
            m = len(path)

            if 9 - i + 1 < k - m:
                return

            if m == k:
                if target == 0:
                    res.append(path.copy())
                return
            
            for j in range(i, 10):
                path.append(j)
                backtrack(j + 1, target - j)
                path.pop()

        backtrack(1, n)
        return res
```