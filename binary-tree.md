# 二叉树 Binary Tree

## 1. 树基础

> 树（Tree）：由 $n \geq 0$ 个节点与节点组合组成的有限集合。当$n = 0$ 时，树被称为**空树**；当 $n > 0$ 时，树被称为**非空树**。

### 1.1 节点分类
* **节点的度**：节点所含有子树的个数
* **叶子节点**：也叫做 **终端节点**，度为`0`。
* **分支节点**：也叫做 **非终端节点**，度不为`0`。

### 1.2 节点间关系
* **子节点**：一个节点含有的子树的根节点称为该节点的子节点。
* **父节点**：如果一个节点含有子节点，则这个节点称为子节点的父节点。
* **兄弟节点**：具有相同父节点的节点互称为兄弟节点。

## 2. 二叉树基础
> 二叉树（Binary Tree）：树中各个节点度不大于2的有序树称为二叉树。
* 二叉树最多有两个子树，称为「左子树」和「右子树」。
* 二叉树左右子树不可以互换。

### 2.1 二叉树种类
#### 2.1.1 满二叉树 Full Binary Tree
> 满二叉树（Full Binary Tree）：如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上，则称该二叉树为满二叉树。
* 即满二叉树只有度为0或2的节点，并且度为0的节点在同一层上。

#### 2.1.2 完全二叉树 Complete Binary Tree
> 完全二叉树（Complete Binary Tree）：如果叶子节点只能出现在最下面两层，并且最下层的叶子节点都依次排列在该层最左边的位置上，具有这种特点的二叉树称为完全二叉树。

完全二叉树要满足：
* 叶子节点只能出现在下面两层
* 除了最底层可能没有填满之外，其余每层节点数量达到最大值
* 最下层的叶子节点集中在该层左边
* 若最底层为`h`层（`h`从`1`开始），则最底层节点个数为`1 ~ 2^(h-1)`
  
注意：满二叉树是完全二叉树的一种特殊情况。

#### 2.1.3 二叉搜索树 Binary Search Tree
二叉搜索树是一个有序树，并满足一下性质：
* 对于一个节点来说，如果它的**左子树**不为空，则左子树上所有节点的值均**小于**它的根节点的值
* 对于一个节点来说，如果它的**右子树**不为空，则右子树上所有节点的值均**大于**它的根节点的值
* 任意节点的左、右子树也是二叉搜索树

#### 2.1.4 平衡二叉搜索树 Balanced Binary Search Tree
> 平衡二叉搜索树（Balanced Binary Tree）：又称为**AVL Tree**。是一种结构平衡的二叉搜索树。即叶节点高度差的绝对值不超过1，并且左、右两个子树都是一棵平衡二叉搜索树。

AVL树满足以下性质：
* 空二叉树是一个AVL树
* 如果`T`是一个AVL树，它的左、右子树也是AVL树
* AVL树的高度为`O(logn)`


### 2.2 二叉树的存储方式
二叉树的存储结构分为「顺序存储」和「链式存储」。

#### 2.2.1 二叉树顺序存储
* 二叉树顺序存储使用一个**一维数组**来存储二叉树的节点。
* 节点位置采用**完全二叉树**的节点层次编号，从上到下，每一层从左到右依次存放二叉树元素。
* 如果对应位置的二叉树元素不存在，则存放「空节点」。

数组和二叉树对应关系：
* 如果某个二叉树节点编号为`i`，且该节点不是叶子节点，其**左子节点**下标为`2 * i + 1`，**右子节点**下标为`2 * i + 2`。
* 如果某个二叉树节点编号为`i`，且该节点是叶子节点，其**根节点**下标为`(i - 1) // 2`

顺序存储特点：
* 对于**完全二叉树**，特别是**满二叉树**，使用顺序存储能充分利用空间，所以使用顺序存储很合理
* 对于一般二叉树来说，顺序存储要设置很多空节点，会浪费空间
* 二叉树顺序存储时插入、删除操作效率低

#### 2.2.2 二叉树链式存储
* 二叉树链式存储使用**链表**来存储二叉树的节点
* 每个链节点`node`包含一个数据域`val`存储节点信息，包含两个指针域`left`和`right`，分别指向左子节点和右子节点。

二叉树链式存储的定义：
Python
```Py
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```
Java
```Java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    // constructor
    TreeNode() {}
    TreeNode(int val) {this.val = val;}
    TreeNode(int val, TreeNode left, TreeNode left) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```
